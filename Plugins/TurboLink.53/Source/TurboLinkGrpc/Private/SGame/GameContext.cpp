//Generated by TurboLink CodeGenerator, do not edit!
#include "GameContext.h"
#include "SGame/GameClient.h"
#include "GameService_Private.h"
#include "GameMarshaling.h"
#include "TurboLinkGrpcManager.h"

GrpcContext_DungeonService_Login::GrpcContext_DungeonService_Login(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_DungeonService_Login::Call(const FGrpcGameLoginRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::game::LoginRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UDungeonService* service = (UDungeonService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncLogin(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_DungeonService_Login::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::game::LoginResponse* _RpcResponse) 
		{
			UDungeonServiceClient* client = (UDungeonServiceClient*)(this->Client);
			if (!(client->OnLoginResponse.IsBound())) return;

			FGrpcGameLoginResponse response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnLoginResponse.Broadcast(Handle, _Result, response);
		}
	);
}

GrpcContext_DungeonService_Logout::GrpcContext_DungeonService_Logout(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_DungeonService_Logout::Call(const FGrpcGameLogoutRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::game::LogoutRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UDungeonService* service = (UDungeonService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncLogout(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_DungeonService_Logout::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::game::LogoutResponse* _RpcResponse) 
		{
			UDungeonServiceClient* client = (UDungeonServiceClient*)(this->Client);
			if (!(client->OnLogoutResponse.IsBound())) return;

			FGrpcGameLogoutResponse response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnLogoutResponse.Broadcast(Handle, _Result, response);
		}
	);
}

GrpcContext_DungeonService_GetCurrentRoom::GrpcContext_DungeonService_GetCurrentRoom(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_DungeonService_GetCurrentRoom::Call(const FGrpcGamePlayerRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::game::PlayerRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UDungeonService* service = (UDungeonService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncGetCurrentRoom(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_DungeonService_GetCurrentRoom::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::game::RoomResponse* _RpcResponse) 
		{
			UDungeonServiceClient* client = (UDungeonServiceClient*)(this->Client);
			if (!(client->OnGetCurrentRoomResponse.IsBound())) return;

			FGrpcGameRoomResponse response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnGetCurrentRoomResponse.Broadcast(Handle, _Result, response);
		}
	);
}

GrpcContext_DungeonService_Move::GrpcContext_DungeonService_Move(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_DungeonService_Move::Call(const FGrpcGameMoveRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::game::MoveRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UDungeonService* service = (UDungeonService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncMove(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_DungeonService_Move::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::game::RoomResponse* _RpcResponse) 
		{
			UDungeonServiceClient* client = (UDungeonServiceClient*)(this->Client);
			if (!(client->OnMoveResponse.IsBound())) return;

			FGrpcGameRoomResponse response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnMoveResponse.Broadcast(Handle, _Result, response);
		}
	);
}

GrpcContext_DungeonService_GetDungeonData::GrpcContext_DungeonService_GetDungeonData(FGrpcContextHandle _Handle, UGrpcService* _Service, UGrpcClient* _Client)
	: Super(_Handle, _Service, _Client)
{
}

void GrpcContext_DungeonService_GetDungeonData::Call(const FGrpcGameGetDungeonDataRequest& Request)
{
	check(GetState() == EGrpcContextState::Ready);
	UpdateState(EGrpcContextState::Initialing);

	::game::GetDungeonDataRequest rpcRequest;
	TURBOLINK_TO_GRPC(&Request, &rpcRequest);

	UDungeonService* service = (UDungeonService*)Service;
	RpcReaderWriter = service->d->Stub->AsyncGetDungeonData(RpcContext.get(), rpcRequest, service->TurboLinkManager->d->CompletionQueue.get());
	RpcReaderWriter->ReadInitialMetadata(InitialTag);
}

void GrpcContext_DungeonService_GetDungeonData::OnRpcEvent(bool Ok, const void* EventTag)
{
	Super::OnRpcEventInternal(Ok, EventTag, 
		[this](const FGrpcResult& _Result, ::game::GetDungeonDataResponse* _RpcResponse) 
		{
			UDungeonServiceClient* client = (UDungeonServiceClient*)(this->Client);
			if (!(client->OnGetDungeonDataResponse.IsBound())) return;

			FGrpcGameGetDungeonDataResponse response;
			if (_RpcResponse) {
				GRPC_TO_TURBOLINK(_RpcResponse, &response);
			}
			client->OnGetDungeonDataResponse.Broadcast(Handle, _Result, response);
		}
	);
}
