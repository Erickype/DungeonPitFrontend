//Generated by TurboLink CodeGenerator, do not edit!
#include "SGame/GameNode.h"
#include "SGame/GameService.h"
#include "TurboLinkGrpcManager.h"
#include "TurboLinkGrpcUtilities.h"
#include "Engine/World.h"
#include "TimerManager.h"
#include "Runtime/Launch/Resources/Version.h"

UCallDungeonServiceLogin* UCallDungeonServiceLogin::Login(UObject* WorldContextObject, const FGrpcGameLoginRequest& request, FGrpcMetaData metaData, float deadLineSeconds)
{
	UCallDungeonServiceLogin* node = NewObject<UCallDungeonServiceLogin>(WorldContextObject);
	UTurboLinkGrpcManager* turboLinkManager = UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(WorldContextObject);

	node->DungeonService = Cast<UDungeonService>(turboLinkManager->MakeService("DungeonService"));
	if (node->DungeonService == nullptr)
	{
		return nullptr;
	}
	node->ServiceState = EGrpcServiceState::Idle;
	node->Request = request;
	node->MetaData = metaData;
	node->DeadLineSeconds = deadLineSeconds;

	node->DungeonService->OnServiceStateChanged.AddUniqueDynamic(node, &UCallDungeonServiceLogin::OnServiceStateChanged);
	return node;
}

void UCallDungeonServiceLogin::Activate()
{
	DungeonService->Connect();
}

void UCallDungeonServiceLogin::OnServiceStateChanged(EGrpcServiceState NewState)
{
	if (ServiceState == NewState) return;
	ServiceState = NewState;

	if (NewState == EGrpcServiceState::TransientFailure)
	{
		FGrpcResult result;
		result.Code = EGrpcResultCode::ConnectionFailed;

		FGrpcGameLoginResponse response;
		OnFail.Broadcast(result, response);

		Shutdown();
		return;
	}

	if (NewState == EGrpcServiceState::Ready)
	{
		DungeonServiceClient = DungeonService->MakeClient();
		DungeonServiceClient->OnContextStateChange.AddUniqueDynamic(this, &UCallDungeonServiceLogin::OnContextStateChange);
		DungeonServiceClient->OnLoginResponse.AddUniqueDynamic(this, &UCallDungeonServiceLogin::OnResponse);

		Context = DungeonServiceClient->InitLogin();
		DungeonServiceClient->Login(Context, Request, MetaData, DeadLineSeconds);
	}
}

void UCallDungeonServiceLogin::OnContextStateChange(FGrpcContextHandle Handle, EGrpcContextState State)
{
	if (State == EGrpcContextState::Done)
	{
		Shutdown();
	}
}

void UCallDungeonServiceLogin::OnResponse(FGrpcContextHandle Handle, const FGrpcResult& GrpcResult, const FGrpcGameLoginResponse& Response)
{
	if (GrpcResult.Code == EGrpcResultCode::Ok)
	{
		OnLoginResponse.Broadcast(GrpcResult, Response);
	}
	else
	{
		OnFail.Broadcast(GrpcResult, Response);
	}
}

void UCallDungeonServiceLogin::Shutdown()
{
	DungeonService->OnServiceStateChanged.RemoveDynamic(this, &UCallDungeonServiceLogin::OnServiceStateChanged);
	if (DungeonServiceClient != nullptr)
	{
		DungeonService->RemoveClient(DungeonServiceClient);
		DungeonServiceClient->Shutdown();
		DungeonServiceClient = nullptr;
	}

	if (DungeonService != nullptr)
	{
		UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(this)->ReleaseService(DungeonService);
		DungeonService = nullptr;
	}

	SetReadyToDestroy();
#if ENGINE_MAJOR_VERSION>=5
	MarkAsGarbage();
#else
	MarkPendingKill();
#endif
}

UCallDungeonServiceLogout* UCallDungeonServiceLogout::Logout(UObject* WorldContextObject, const FGrpcGameLogoutRequest& request, FGrpcMetaData metaData, float deadLineSeconds)
{
	UCallDungeonServiceLogout* node = NewObject<UCallDungeonServiceLogout>(WorldContextObject);
	UTurboLinkGrpcManager* turboLinkManager = UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(WorldContextObject);

	node->DungeonService = Cast<UDungeonService>(turboLinkManager->MakeService("DungeonService"));
	if (node->DungeonService == nullptr)
	{
		return nullptr;
	}
	node->ServiceState = EGrpcServiceState::Idle;
	node->Request = request;
	node->MetaData = metaData;
	node->DeadLineSeconds = deadLineSeconds;

	node->DungeonService->OnServiceStateChanged.AddUniqueDynamic(node, &UCallDungeonServiceLogout::OnServiceStateChanged);
	return node;
}

void UCallDungeonServiceLogout::Activate()
{
	DungeonService->Connect();
}

void UCallDungeonServiceLogout::OnServiceStateChanged(EGrpcServiceState NewState)
{
	if (ServiceState == NewState) return;
	ServiceState = NewState;

	if (NewState == EGrpcServiceState::TransientFailure)
	{
		FGrpcResult result;
		result.Code = EGrpcResultCode::ConnectionFailed;

		FGrpcGameLogoutResponse response;
		OnFail.Broadcast(result, response);

		Shutdown();
		return;
	}

	if (NewState == EGrpcServiceState::Ready)
	{
		DungeonServiceClient = DungeonService->MakeClient();
		DungeonServiceClient->OnContextStateChange.AddUniqueDynamic(this, &UCallDungeonServiceLogout::OnContextStateChange);
		DungeonServiceClient->OnLogoutResponse.AddUniqueDynamic(this, &UCallDungeonServiceLogout::OnResponse);

		Context = DungeonServiceClient->InitLogout();
		DungeonServiceClient->Logout(Context, Request, MetaData, DeadLineSeconds);
	}
}

void UCallDungeonServiceLogout::OnContextStateChange(FGrpcContextHandle Handle, EGrpcContextState State)
{
	if (State == EGrpcContextState::Done)
	{
		Shutdown();
	}
}

void UCallDungeonServiceLogout::OnResponse(FGrpcContextHandle Handle, const FGrpcResult& GrpcResult, const FGrpcGameLogoutResponse& Response)
{
	if (GrpcResult.Code == EGrpcResultCode::Ok)
	{
		OnLogoutResponse.Broadcast(GrpcResult, Response);
	}
	else
	{
		OnFail.Broadcast(GrpcResult, Response);
	}
}

void UCallDungeonServiceLogout::Shutdown()
{
	DungeonService->OnServiceStateChanged.RemoveDynamic(this, &UCallDungeonServiceLogout::OnServiceStateChanged);
	if (DungeonServiceClient != nullptr)
	{
		DungeonService->RemoveClient(DungeonServiceClient);
		DungeonServiceClient->Shutdown();
		DungeonServiceClient = nullptr;
	}

	if (DungeonService != nullptr)
	{
		UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(this)->ReleaseService(DungeonService);
		DungeonService = nullptr;
	}

	SetReadyToDestroy();
#if ENGINE_MAJOR_VERSION>=5
	MarkAsGarbage();
#else
	MarkPendingKill();
#endif
}

UCallDungeonServiceGetCurrentRoom* UCallDungeonServiceGetCurrentRoom::GetCurrentRoom(UObject* WorldContextObject, const FGrpcGamePlayerRequest& request, FGrpcMetaData metaData, float deadLineSeconds)
{
	UCallDungeonServiceGetCurrentRoom* node = NewObject<UCallDungeonServiceGetCurrentRoom>(WorldContextObject);
	UTurboLinkGrpcManager* turboLinkManager = UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(WorldContextObject);

	node->DungeonService = Cast<UDungeonService>(turboLinkManager->MakeService("DungeonService"));
	if (node->DungeonService == nullptr)
	{
		return nullptr;
	}
	node->ServiceState = EGrpcServiceState::Idle;
	node->Request = request;
	node->MetaData = metaData;
	node->DeadLineSeconds = deadLineSeconds;

	node->DungeonService->OnServiceStateChanged.AddUniqueDynamic(node, &UCallDungeonServiceGetCurrentRoom::OnServiceStateChanged);
	return node;
}

void UCallDungeonServiceGetCurrentRoom::Activate()
{
	DungeonService->Connect();
}

void UCallDungeonServiceGetCurrentRoom::OnServiceStateChanged(EGrpcServiceState NewState)
{
	if (ServiceState == NewState) return;
	ServiceState = NewState;

	if (NewState == EGrpcServiceState::TransientFailure)
	{
		FGrpcResult result;
		result.Code = EGrpcResultCode::ConnectionFailed;

		FGrpcGameRoomResponse response;
		OnFail.Broadcast(result, response);

		Shutdown();
		return;
	}

	if (NewState == EGrpcServiceState::Ready)
	{
		DungeonServiceClient = DungeonService->MakeClient();
		DungeonServiceClient->OnContextStateChange.AddUniqueDynamic(this, &UCallDungeonServiceGetCurrentRoom::OnContextStateChange);
		DungeonServiceClient->OnGetCurrentRoomResponse.AddUniqueDynamic(this, &UCallDungeonServiceGetCurrentRoom::OnResponse);

		Context = DungeonServiceClient->InitGetCurrentRoom();
		DungeonServiceClient->GetCurrentRoom(Context, Request, MetaData, DeadLineSeconds);
	}
}

void UCallDungeonServiceGetCurrentRoom::OnContextStateChange(FGrpcContextHandle Handle, EGrpcContextState State)
{
	if (State == EGrpcContextState::Done)
	{
		Shutdown();
	}
}

void UCallDungeonServiceGetCurrentRoom::OnResponse(FGrpcContextHandle Handle, const FGrpcResult& GrpcResult, const FGrpcGameRoomResponse& Response)
{
	if (GrpcResult.Code == EGrpcResultCode::Ok)
	{
		OnGetCurrentRoomResponse.Broadcast(GrpcResult, Response);
	}
	else
	{
		OnFail.Broadcast(GrpcResult, Response);
	}
}

void UCallDungeonServiceGetCurrentRoom::Shutdown()
{
	DungeonService->OnServiceStateChanged.RemoveDynamic(this, &UCallDungeonServiceGetCurrentRoom::OnServiceStateChanged);
	if (DungeonServiceClient != nullptr)
	{
		DungeonService->RemoveClient(DungeonServiceClient);
		DungeonServiceClient->Shutdown();
		DungeonServiceClient = nullptr;
	}

	if (DungeonService != nullptr)
	{
		UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(this)->ReleaseService(DungeonService);
		DungeonService = nullptr;
	}

	SetReadyToDestroy();
#if ENGINE_MAJOR_VERSION>=5
	MarkAsGarbage();
#else
	MarkPendingKill();
#endif
}

UCallDungeonServiceMove* UCallDungeonServiceMove::Move(UObject* WorldContextObject, const FGrpcGameMoveRequest& request, FGrpcMetaData metaData, float deadLineSeconds)
{
	UCallDungeonServiceMove* node = NewObject<UCallDungeonServiceMove>(WorldContextObject);
	UTurboLinkGrpcManager* turboLinkManager = UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(WorldContextObject);

	node->DungeonService = Cast<UDungeonService>(turboLinkManager->MakeService("DungeonService"));
	if (node->DungeonService == nullptr)
	{
		return nullptr;
	}
	node->ServiceState = EGrpcServiceState::Idle;
	node->Request = request;
	node->MetaData = metaData;
	node->DeadLineSeconds = deadLineSeconds;

	node->DungeonService->OnServiceStateChanged.AddUniqueDynamic(node, &UCallDungeonServiceMove::OnServiceStateChanged);
	return node;
}

void UCallDungeonServiceMove::Activate()
{
	DungeonService->Connect();
}

void UCallDungeonServiceMove::OnServiceStateChanged(EGrpcServiceState NewState)
{
	if (ServiceState == NewState) return;
	ServiceState = NewState;

	if (NewState == EGrpcServiceState::TransientFailure)
	{
		FGrpcResult result;
		result.Code = EGrpcResultCode::ConnectionFailed;

		FGrpcGameRoomResponse response;
		OnFail.Broadcast(result, response);

		Shutdown();
		return;
	}

	if (NewState == EGrpcServiceState::Ready)
	{
		DungeonServiceClient = DungeonService->MakeClient();
		DungeonServiceClient->OnContextStateChange.AddUniqueDynamic(this, &UCallDungeonServiceMove::OnContextStateChange);
		DungeonServiceClient->OnMoveResponse.AddUniqueDynamic(this, &UCallDungeonServiceMove::OnResponse);

		Context = DungeonServiceClient->InitMove();
		DungeonServiceClient->Move(Context, Request, MetaData, DeadLineSeconds);
	}
}

void UCallDungeonServiceMove::OnContextStateChange(FGrpcContextHandle Handle, EGrpcContextState State)
{
	if (State == EGrpcContextState::Done)
	{
		Shutdown();
	}
}

void UCallDungeonServiceMove::OnResponse(FGrpcContextHandle Handle, const FGrpcResult& GrpcResult, const FGrpcGameRoomResponse& Response)
{
	if (GrpcResult.Code == EGrpcResultCode::Ok)
	{
		OnMoveResponse.Broadcast(GrpcResult, Response);
	}
	else
	{
		OnFail.Broadcast(GrpcResult, Response);
	}
}

void UCallDungeonServiceMove::Shutdown()
{
	DungeonService->OnServiceStateChanged.RemoveDynamic(this, &UCallDungeonServiceMove::OnServiceStateChanged);
	if (DungeonServiceClient != nullptr)
	{
		DungeonService->RemoveClient(DungeonServiceClient);
		DungeonServiceClient->Shutdown();
		DungeonServiceClient = nullptr;
	}

	if (DungeonService != nullptr)
	{
		UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(this)->ReleaseService(DungeonService);
		DungeonService = nullptr;
	}

	SetReadyToDestroy();
#if ENGINE_MAJOR_VERSION>=5
	MarkAsGarbage();
#else
	MarkPendingKill();
#endif
}

UCallDungeonServiceGetDungeonData* UCallDungeonServiceGetDungeonData::GetDungeonData(UObject* WorldContextObject, const FGrpcGameGetDungeonDataRequest& request, FGrpcMetaData metaData, float deadLineSeconds)
{
	UCallDungeonServiceGetDungeonData* node = NewObject<UCallDungeonServiceGetDungeonData>(WorldContextObject);
	UTurboLinkGrpcManager* turboLinkManager = UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(WorldContextObject);

	node->DungeonService = Cast<UDungeonService>(turboLinkManager->MakeService("DungeonService"));
	if (node->DungeonService == nullptr)
	{
		return nullptr;
	}
	node->ServiceState = EGrpcServiceState::Idle;
	node->Request = request;
	node->MetaData = metaData;
	node->DeadLineSeconds = deadLineSeconds;

	node->DungeonService->OnServiceStateChanged.AddUniqueDynamic(node, &UCallDungeonServiceGetDungeonData::OnServiceStateChanged);
	return node;
}

void UCallDungeonServiceGetDungeonData::Activate()
{
	DungeonService->Connect();
}

void UCallDungeonServiceGetDungeonData::OnServiceStateChanged(EGrpcServiceState NewState)
{
	if (ServiceState == NewState) return;
	ServiceState = NewState;

	if (NewState == EGrpcServiceState::TransientFailure)
	{
		FGrpcResult result;
		result.Code = EGrpcResultCode::ConnectionFailed;

		FGrpcGameGetDungeonDataResponse response;
		OnFail.Broadcast(result, response);

		Shutdown();
		return;
	}

	if (NewState == EGrpcServiceState::Ready)
	{
		DungeonServiceClient = DungeonService->MakeClient();
		DungeonServiceClient->OnContextStateChange.AddUniqueDynamic(this, &UCallDungeonServiceGetDungeonData::OnContextStateChange);
		DungeonServiceClient->OnGetDungeonDataResponse.AddUniqueDynamic(this, &UCallDungeonServiceGetDungeonData::OnResponse);

		Context = DungeonServiceClient->InitGetDungeonData();
		DungeonServiceClient->GetDungeonData(Context, Request, MetaData, DeadLineSeconds);
	}
}

void UCallDungeonServiceGetDungeonData::OnContextStateChange(FGrpcContextHandle Handle, EGrpcContextState State)
{
	if (State == EGrpcContextState::Done)
	{
		Shutdown();
	}
}

void UCallDungeonServiceGetDungeonData::OnResponse(FGrpcContextHandle Handle, const FGrpcResult& GrpcResult, const FGrpcGameGetDungeonDataResponse& Response)
{
	if (GrpcResult.Code == EGrpcResultCode::Ok)
	{
		OnGetDungeonDataResponse.Broadcast(GrpcResult, Response);
	}
	else
	{
		OnFail.Broadcast(GrpcResult, Response);
	}
}

void UCallDungeonServiceGetDungeonData::Shutdown()
{
	DungeonService->OnServiceStateChanged.RemoveDynamic(this, &UCallDungeonServiceGetDungeonData::OnServiceStateChanged);
	if (DungeonServiceClient != nullptr)
	{
		DungeonService->RemoveClient(DungeonServiceClient);
		DungeonServiceClient->Shutdown();
		DungeonServiceClient = nullptr;
	}

	if (DungeonService != nullptr)
	{
		UTurboLinkGrpcUtilities::GetTurboLinkGrpcManager(this)->ReleaseService(DungeonService);
		DungeonService = nullptr;
	}

	SetReadyToDestroy();
#if ENGINE_MAJOR_VERSION>=5
	MarkAsGarbage();
#else
	MarkPendingKill();
#endif
}
