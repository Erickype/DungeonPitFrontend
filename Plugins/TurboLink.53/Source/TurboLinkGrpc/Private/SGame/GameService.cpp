//Generated by TurboLink CodeGenerator, do not edit!
#include "SGame/GameService.h"
#include "SGame/GameClient.h"
#include "GameService_Private.h"
#include "GameMarshaling.h"
#include "TurboLinkGrpcManager_Private.h"
#include "TurboLinkGrpcUtilities.h"

UDungeonService::UDungeonService()
	: d(new UDungeonService::Private())
{
}

UDungeonService::~UDungeonService()
{
	delete d;
}

void UDungeonService::Connect()
{
	FString serviceEndPoint = UTurboLinkGrpcUtilities::GetTurboLinkGrpcConfig()->GetServiceEndPoint(TEXT("DungeonService"));
	UE_LOG(LogTurboLink, Warning, TEXT("Connect to DungeonService: '%s'"), *serviceEndPoint);

	if (d->Channel == nullptr) {
		d->Channel = TurboLinkManager->d->CreateServiceChannel((const char*)StringCast<UTF8CHAR>(*serviceEndPoint).Get(), this);
	}
	if (d->Stub == nullptr) {
		d->Stub = game::DungeonService::NewStub(d->Channel->RpcChannel);
	}

	grpc_connectivity_state currentChannelState = d->Channel->RpcChannel->GetState(true);
	if (OnServiceStateChanged.IsBound())
	{
		OnServiceStateChanged.Broadcast(UTurboLinkGrpcManager::Private::GrpcStateToServiceState(currentChannelState));
	}
}

EGrpcServiceState UDungeonService::GetServiceState() const
{
	if (d->Channel == nullptr) return EGrpcServiceState::NotCreate;

	auto rpcChannelState = d->Channel->RpcChannel->GetState(false);
	return UTurboLinkGrpcManager::Private::GrpcStateToServiceState(rpcChannelState);
}

UDungeonServiceClient* UDungeonService::MakeClient()
{
	auto client = UGrpcService::MakeClient<UDungeonServiceClient>();
	return client;
}

void UDungeonService::Shutdown()
{
	Super::Shutdown();
	d->Stub = nullptr;
	if (d->Channel != nullptr) {
		TurboLinkManager->d->RemoveServiceChannel(d->Channel, this);
		d->Channel = nullptr;
	}
}

void UDungeonService::CallLogin(const FGrpcGameLoginRequest& Request, FLoginResponseLambda ResponseLambda, FGrpcMetaData MetaData, float DeadLineSeconds)
{
	if (InnerClient == nullptr)
	{
		InnerClient = MakeClient();
	}
	UDungeonServiceLoginLambdaWrapper* lambdaWrapper = NewObject<UDungeonServiceLoginLambdaWrapper>();
	lambdaWrapper->InnerClient = InnerClient;
	lambdaWrapper->ResponseLambda = ResponseLambda;
	lambdaWrapper->Handle = InnerClient->InitLogin();
	InnerClient->OnLoginResponse.AddUniqueDynamic(lambdaWrapper, &UDungeonServiceLoginLambdaWrapper::OnResponse);
	InnerClient->Login(lambdaWrapper->Handle, Request, MetaData, DeadLineSeconds);
}

void UDungeonService::CallLogout(const FGrpcGameLogoutRequest& Request, FLogoutResponseLambda ResponseLambda, FGrpcMetaData MetaData, float DeadLineSeconds)
{
	if (InnerClient == nullptr)
	{
		InnerClient = MakeClient();
	}
	UDungeonServiceLogoutLambdaWrapper* lambdaWrapper = NewObject<UDungeonServiceLogoutLambdaWrapper>();
	lambdaWrapper->InnerClient = InnerClient;
	lambdaWrapper->ResponseLambda = ResponseLambda;
	lambdaWrapper->Handle = InnerClient->InitLogout();
	InnerClient->OnLogoutResponse.AddUniqueDynamic(lambdaWrapper, &UDungeonServiceLogoutLambdaWrapper::OnResponse);
	InnerClient->Logout(lambdaWrapper->Handle, Request, MetaData, DeadLineSeconds);
}

void UDungeonService::CallGetCurrentRoom(const FGrpcGamePlayerRequest& Request, FGetCurrentRoomResponseLambda ResponseLambda, FGrpcMetaData MetaData, float DeadLineSeconds)
{
	if (InnerClient == nullptr)
	{
		InnerClient = MakeClient();
	}
	UDungeonServiceGetCurrentRoomLambdaWrapper* lambdaWrapper = NewObject<UDungeonServiceGetCurrentRoomLambdaWrapper>();
	lambdaWrapper->InnerClient = InnerClient;
	lambdaWrapper->ResponseLambda = ResponseLambda;
	lambdaWrapper->Handle = InnerClient->InitGetCurrentRoom();
	InnerClient->OnGetCurrentRoomResponse.AddUniqueDynamic(lambdaWrapper, &UDungeonServiceGetCurrentRoomLambdaWrapper::OnResponse);
	InnerClient->GetCurrentRoom(lambdaWrapper->Handle, Request, MetaData, DeadLineSeconds);
}

void UDungeonService::CallMove(const FGrpcGameMoveRequest& Request, FMoveResponseLambda ResponseLambda, FGrpcMetaData MetaData, float DeadLineSeconds)
{
	if (InnerClient == nullptr)
	{
		InnerClient = MakeClient();
	}
	UDungeonServiceMoveLambdaWrapper* lambdaWrapper = NewObject<UDungeonServiceMoveLambdaWrapper>();
	lambdaWrapper->InnerClient = InnerClient;
	lambdaWrapper->ResponseLambda = ResponseLambda;
	lambdaWrapper->Handle = InnerClient->InitMove();
	InnerClient->OnMoveResponse.AddUniqueDynamic(lambdaWrapper, &UDungeonServiceMoveLambdaWrapper::OnResponse);
	InnerClient->Move(lambdaWrapper->Handle, Request, MetaData, DeadLineSeconds);
}

void UDungeonService::CallGetDungeonData(const FGrpcGameGetDungeonDataRequest& Request, FGetDungeonDataResponseLambda ResponseLambda, FGrpcMetaData MetaData, float DeadLineSeconds)
{
	if (InnerClient == nullptr)
	{
		InnerClient = MakeClient();
	}
	UDungeonServiceGetDungeonDataLambdaWrapper* lambdaWrapper = NewObject<UDungeonServiceGetDungeonDataLambdaWrapper>();
	lambdaWrapper->InnerClient = InnerClient;
	lambdaWrapper->ResponseLambda = ResponseLambda;
	lambdaWrapper->Handle = InnerClient->InitGetDungeonData();
	InnerClient->OnGetDungeonDataResponse.AddUniqueDynamic(lambdaWrapper, &UDungeonServiceGetDungeonDataLambdaWrapper::OnResponse);
	InnerClient->GetDungeonData(lambdaWrapper->Handle, Request, MetaData, DeadLineSeconds);
}
